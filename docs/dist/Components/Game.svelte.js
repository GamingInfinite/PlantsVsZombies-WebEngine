import './Game.svelte.css.proxy.js';
/* src/Components/Game.svelte generated by Svelte v3.48.0 */
import {
	SvelteComponent,
	attr,
	detach,
	element,
	init,
	insert,
	noop,
	safe_not_equal
} from "../../snowpack/pkg/svelte/internal.js";

import { onMount } from "../../snowpack/pkg/svelte.js";

import {
	Plants,
	PlantAnimFrameCounts,
	PacketPortraitPaths,
	PlantAnimPaths,
	PlantIdleFrameOrder,
	PlantSpriteSizeRatio,
	PlantSunCost,
	PlantRechargeTime
} from "../enums.js";

function create_fragment(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.innerHTML = `<canvas id="game" width="1920" height="1080" class="svelte-1fyqfil"></canvas>`;
			attr(div, "id", "gameWrapper");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

var FPS = 60;

//Draw Falling and Produced Sun
function drawSunObjects(ctx, height, width) {
	
}

function instance($$self, $$props, $$invalidate) {
	let { boardType } = $$props;
	let { allowPick = false } = $$props;
	let { maxPlants = 1 } = $$props;
	let { setPicks = [Plants.SUNFLOWER] } = $$props;
	let { sunCount = 50 } = $$props;
	let rechargeTime = [];
	var boardInUse;
	var boardXOffset;
	var boardYOffset;
	var laneHeight;
	var laneWidth;
	var tileWidth;
	var packetsOffset;

	let boards = [
		{
			name: "frontLawn",
			lanes: [{ type: "grass", number: 5 }],
			colors: [0, 1, 0, 1, 0]
		},
		{
			name: "tutorial1",
			lanes: [
				{ type: "dirt", number: 2 },
				{ type: "grass", number: 1 },
				{ type: "dirt", number: 2 }
			],
			colors: [0, 0, 0, 0, 0]
		}
	];

	let types = [
		{
			name: "grass",
			colors: ["#154f1a", "#33b83e"]
		},
		{ name: "dirt", colors: ["#836539"] }
	];

	let selectedSeed = -1;
	let selectedX;
	let selectedY;
	var lanes = [];
	var loadedPorts = [];
	var resourceImages = [];

	var seedPortaits = [
		PacketPortraitPaths.SUNFLOWER,
		PacketPortraitPaths.PEASHOOTER,
		PacketPortraitPaths.BONKCHOY
	];

	var plantAnims = [];

	function loadImages() {
		var packetBG = new Image();
		var sunIcon = new Image();

		if (window.location.href.indexOf("github") > -1) {
			packetBG.src = "PlantsVsZombies-WebEngine/" + PacketPortraitPaths.BG;
			sunIcon.src = "PlantsVsZombies-WebEngine/" + "images/resources/sun/sun.png";
		} else {
			packetBG.src = PacketPortraitPaths.BG;
			sunIcon.src = "images/resources/sun/sun.png";
		}

		resourceImages.push(sunIcon);
		loadedPorts.push(packetBG);

		for (let i = 0; i < maxPlants; i++) {
			let plantPort = new Image();

			if (window.location.href.indexOf("github") > -1) {
				plantPort.src = "PlantsVsZombies-WebEngine/" + seedPortaits[setPicks[i]];
			} else {
				plantPort.src = seedPortaits[setPicks[i]];
			}

			loadedPorts.push(plantPort);
			let plantIdle = [];

			for (let j = 0; j < PlantAnimFrameCounts[i]; j++) {
				let plantFrame = new Image();

				if (window.location.href.indexOf("github") > -1) {
					plantFrame.src = "PlantsVsZombies-WebEngine/" + PlantAnimPaths.SUNFLOWER + j + ".png";
				} else {
					plantFrame.src = PlantAnimPaths.SUNFLOWER + j + ".png";
				}

				if (PlantIdleFrameOrder[i].includes(j)) {
					plantIdle.push(plantFrame);
				}
			}

			plantAnims.push(plantIdle);
		}
	}

	CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
		if (width < 2 * radius) radius = width / 2;
		if (height < 2 * radius) radius = height / 2;
		this.beginPath();
		this.moveTo(x + radius, y);
		this.arcTo(x + width, y, x + width, y + height, radius);
		this.arcTo(x + width, y + height, x, y + height, radius);
		this.arcTo(x, y + height, x, y, radius);
		this.arcTo(x, y, x + width, y, radius);
		this.closePath();
		return this;
	};

	//Gets the json file from the boards array
	function getBoardJson(boardKey) {
		for (let i = 0; i < boards.length; i++) {
			const element = boards[i];

			if (element.name == boardKey) {
				boardInUse = element;
			}
		}
	}

	//Fills the lanes array
	function parseLanes() {
		for (let i = 0; i < boardInUse.lanes.length; i++) {
			const element = boardInUse.lanes[i];

			for (let j = 0; j < element.number; j++) {
				lanes.push(element.type);
			}
		}
	}

	//Used for drawDebugBoard()
	function getLaneJson(laneKey) {
		for (let i = 0; i < types.length; i++) {
			const element = types[i];

			if (element.name == laneKey) {
				return element;
			}
		}
	}

	function getPacketRecharge() {
		for (let i = 0; i < maxPlants; i++) {
			let rechargePair = [0, PlantRechargeTime[setPicks[i]]];

			switch (setPicks[i]) {
				case 0:
					rechargePair[0] = PlantRechargeTime[setPicks[i]];
					break;
				default:
					break;
			}

			rechargeTime.push(rechargePair);
		}
	}

	//Drawing the Debug Lawn
	function drawDebugBoard(ctx) {
		for (let i = 0; i < lanes.length; i++) {
			const element = lanes[i];

			if (getLaneJson(element).colors.length > 1) {
				for (let j = 0; j < 9; j++) {
					let altColor;

					if (boardInUse.colors[i] == 0) {
						altColor = 1;
					} else {
						altColor = 0;
					}

					if (j % 2 == 0) {
						ctx.fillStyle = getLaneJson(element).colors[boardInUse.colors[i]];
					} else {
						ctx.fillStyle = getLaneJson(element).colors[altColor];
					}

					ctx.fillRect(boardXOffset + j * tileWidth, i * laneHeight + boardYOffset, tileWidth, laneHeight + 1);
				}
			} else {
				ctx.fillStyle = getLaneJson(element).colors[boardInUse.colors[i]];
				ctx.fillRect(boardXOffset, i * laneHeight + boardYOffset, laneWidth, laneHeight + 1);
			}
		}
	}

	//Drawing Seed Packets
	function drawSeedPackets(ctx, height, width) {
		for (let i = 0; i < maxPlants; i++) {
			if (selectedSeed == i) {
				ctx.globalAlpha = 0.5;
				drawPacket(ctx, height, width, i);
				ctx.globalAlpha = 1;
				drawPacketAtCursor(ctx, width, i);
			} else {
				drawPacket(ctx, height, width, i);
				let plantId = setPicks[i];

				if (PlantSunCost[plantId] > sunCount || rechargeTime[i][0] < rechargeTime[i][1]) {
					ctx.fillStyle = "#000";
					ctx.globalAlpha = 0.25;
					ctx.roundRect(packetsOffset + width * 0.12 * i, height * 0.01, width * 0.11, laneHeight, 8);
					ctx.fill();
					ctx.globalAlpha = 1;
				}

				if (rechargeTime[i][0] < rechargeTime[i][1]) {
					let heightFraction = 1 - rechargeTime[i][0] / rechargeTime[i][1];
					ctx.fillStyle = "#000";
					ctx.globalAlpha = 0.25;
					ctx.roundRect(packetsOffset + width * 0.12 * i, height * 0.01, width * 0.11, laneHeight * heightFraction, 8);
					ctx.fill();
					ctx.globalAlpha = 1;
				}
			}
		}
	}

	function drawPacket(ctx, height, width, i) {
		//Draw BG
		ctx.drawImage(loadedPorts[0], packetsOffset + width * 0.12 * i, height * 0.01, width * 0.11, laneHeight);

		//Draw Portrait
		ctx.drawImage(loadedPorts[i + 1], packetsOffset + width * 0.12 * i, height * 0.01, width * 0.11, laneHeight);
	}

	function drawPacketAtCursor(ctx, width, i) {
		//Draw BG
		ctx.drawImage(loadedPorts[0], selectedX - width * 0.11 / 2, selectedY - laneHeight / 2, width * 0.11, laneHeight);

		//Draw Portrait
		ctx.drawImage(loadedPorts[i + 1], selectedX - width * 0.11 / 2, selectedY - laneHeight / 2, width * 0.11, laneHeight);
	}

	var plantsToBeDrawn = [];
	var sunToBeDrawn = [];

	//Drawing Plants | Add support for animations later !!IMPORTANT!!
	function drawPlants(ctx) {
		let plantXOffset = tileWidth * 0.2;
		let plantYOffset = laneHeight * 0.06;

		for (let i = 0; i < plantsToBeDrawn.length; i++) {
			const element = plantsToBeDrawn[i];
			let firstFrame = plantAnims[element.plant][0];
			let tileX = element.tile[0];
			let tileY = element.tile[1];

			//Add support for animations later !!IMPORTANT!!
			ctx.drawImage(firstFrame, boardXOffset + tileX * tileWidth + plantXOffset, tileY * laneHeight + boardYOffset + plantYOffset, laneHeight * 0.9 * PlantSpriteSizeRatio[element.plant], laneHeight * 0.9);
		}
	}

	//Drawing Sun Hud
	function drawSunCount(ctx, height, width) {
		let sunIconXOffset = width * 0.003;
		let sunIconYOffset = height * 0.025;
		let sunCountXOffset = width * 0.055;
		let sunCountYOffset = height * 0.095;
		let sunBgXOffset = width * 0.05 - 20;
		let sunBgYOffset = height * 0.095 - 40;
		ctx.globalAlpha = 0.5;
		ctx.fillStyle = "#000";
		ctx.roundRect(sunBgXOffset, sunBgYOffset, 100, 50, 8);
		ctx.fill();
		ctx.globalAlpha = 1;
		ctx.font = "40px CafeteriaBlack";
		ctx.fillStyle = "#FFF";
		ctx.fillText(sunCount, sunCountXOffset, sunCountYOffset);
		ctx.fillStyle = "#000";
		ctx.strokeText(sunCount, sunCountXOffset, sunCountYOffset);
		ctx.drawImage(resourceImages[0], sunIconXOffset, sunIconYOffset, 100, 100);
	}

	getBoardJson(boardType);
	parseLanes();
	loadImages();
	getPacketRecharge();

	function update() {
		boardXOffset = window.innerWidth * 0.15;
		boardYOffset = window.innerHeight * 0.2;
		packetsOffset = window.innerWidth * 0.1;
		laneHeight = (window.innerHeight - window.innerHeight * 0.3) / 5;
		laneWidth = window.innerWidth * 0.8;
		tileWidth = laneWidth / 9;

		for (let i = 0; i < maxPlants; i++) {
			if (rechargeTime[i][0] < rechargeTime[i][1]) {
				rechargeTime[i][0] += 1;
			}
		}
	}

	function draw() {
		//Frame Draw Preparation
		var canvas = document.getElementById("game");

		var ctx = canvas.getContext("2d");
		let height = window.innerHeight;
		let width = window.innerWidth;
		canvas.height = height;
		canvas.width = width;
		ctx.globalAlpha = 1;

		//Debug Lawn
		drawDebugBoard(ctx);

		//Lawn Art/Image
		//idk put an actual function here later when you get to it
		//Draw Plants
		drawPlants(ctx);

		//Draw Projectiles (Sun, Peas, Darts, What have you)
		drawSunObjects(ctx, height, width);

		//Draw Zombies
		//put function here
		//Draw Foreground
		//put function here
		//Draw HUD (Seeds, Shovel, Sun Count, etc.)
		drawSeedPackets(ctx, height, width);

		drawSunCount(ctx, height, width);
	}

	onMount(() => {
		let eventGame = document.getElementById("game");

		eventGame.onmousedown = function (e) {
			if (selectedSeed == -1) {
				
			} else {
				for (let i = 0; i < lanes.length; i++) {
					for (let j = 0; j < 9; j++) {
						if (lanes[i] == "dirt") {
							break; //Do Nothing I Think
						}

						if (tileHitTest(e.clientX, e.clientY, i, j)) {
							let audio = new Audio("audio/plant1.ogg");
							audio.play();
							let selectedPlantString = Object.keys(Plants)[selectedSeed];
							let drawObject = { plant: selectedPlantString, tile: [j, i] };
							$$invalidate(0, sunCount -= PlantSunCost[selectedSeed]);
							rechargeTime[selectedSeed][0] = 0;
							plantsToBeDrawn.push(drawObject);
						}
					}
				}
			}

			selectedX = e.clientX;
			selectedY = e.clientY;
		};

		eventGame.onmouseup = function (e) {
			if (selectedSeed == -1) {
				for (let i = 0; i < maxPlants; i++) {
					if (PlantSunCost[i] > sunCount) {
						break;
					}

					if (seedPacketHitTest(e.clientX, e.clientY, i)) {
						selectedSeed = i;
					}
				}
			} else {
				selectedSeed = -1;
			}
		};

		eventGame.onmousemove = function (e) {
			if (selectedSeed == -1) {
				return;
			}

			selectedX = e.clientX;
			selectedY = e.clientY;
		};
	});

	function seedPacketHitTest(x, y, i) {
		let width = window.innerWidth;
		let height = window.innerHeight;
		let packetStartX = boardXOffset + width * 0.12 * i;
		let packetStartY = height * 0.01;
		let packetWidth = width * 0.11;
		let packetHeight = laneHeight;
		return x >= packetStartX && x <= packetStartX + packetWidth && y >= packetStartY && y <= packetStartY + packetHeight;
	}

	function tileHitTest(x, y, i, j) {
		let packetStartX = boardXOffset + j * tileWidth;
		let packetStartY = i * laneHeight + boardYOffset;
		let packetWidth = tileWidth;
		let packetHeight = laneHeight + 1;
		return x >= packetStartX && x <= packetStartX + packetWidth && y >= packetStartY && y <= packetStartY + packetHeight;
	}

	setInterval(
		() => {
			update();
			draw();
		},
		1000 / FPS
	);

	$$self.$$set = $$props => {
		if ('boardType' in $$props) $$invalidate(1, boardType = $$props.boardType);
		if ('allowPick' in $$props) $$invalidate(2, allowPick = $$props.allowPick);
		if ('maxPlants' in $$props) $$invalidate(3, maxPlants = $$props.maxPlants);
		if ('setPicks' in $$props) $$invalidate(4, setPicks = $$props.setPicks);
		if ('sunCount' in $$props) $$invalidate(0, sunCount = $$props.sunCount);
	};

	return [sunCount, boardType, allowPick, maxPlants, setPicks];
}

class Game extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				boardType: 1,
				allowPick: 2,
				maxPlants: 3,
				setPicks: 4,
				sunCount: 0
			},
			null,
			[-1, -1]
		);
	}
}

export default Game;